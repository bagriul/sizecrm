from flask import Flask, request, jsonify, Response, session
import jwt
from pymongo import MongoClient, ASCENDING, DESCENDING
from bson import json_util, ObjectId
from flask_cors import CORS
import re
import config
from datetime import datetime, timedelta
import base64
import json
import math
from flask import Flask, redirect, url_for, render_template
from flask_mail import Mail, Message
from flask_dance.contrib.google import make_google_blueprint, google
import requests
from io import BytesIO
from uuid import uuid4
from flask_bcrypt import Bcrypt
import telebot
import random
import string

application = Flask(__name__)
CORS(application)
application.config['SECRET_KEY'] = config.SECRET_KEY
SECRET_KEY = config.SECRET_KEY
client = MongoClient(config.MONGO_STRING)
db = client['size_crm']
users_collection = db['users']
clients_collection = db['clients']
statuses_collection = db['statuses']
orders_collection = db['orders']
tasks_collection = db['tasks']
products_collection = db['products']
warehouses_collection = db['warehouses']
variations_collection = db['variations']
transactions_collection = db['transactions']
cashiers_collection = db['cashiers']
counterparties_collection = db['counterparties']
auto_transactions_collection = db['auto_transactions']
demo_users_collection = db['demo_users']
mailing_history_collection = db['mailing_history']
task_participants_collection = db['task_participants']
products_categories_collection = db['products_categories']
shipping_methods_collection = db['shipping_methods']
order_sources_collection = db['order_sources']
payment_methods_collection = db['payment_methods']
loyalty_collection = db['loyalty']
notifications_collection = db['notifications']

google_bp = make_google_blueprint(client_id='YOUR_GOOGLE_CLIENT_ID',
                                  client_secret='YOUR_GOOGLE_CLIENT_SECRET',
                                  redirect_to='google_login')
application.register_blueprint(google_bp, url_prefix='/google_login')

application.config['MAIL_SERVER'] = 'smtp.gmail.com'
application.config['MAIL_PORT'] = 465  # Use your mail server's port
application.config['MAIL_USE_TLS'] = False
application.config['MAIL_USE_SSL'] = True
application.config['MAIL_USERNAME'] = 'size.crm@gmail.com'
application.config['MAIL_PASSWORD'] = 'wchg bcif xkkr oqga'
application.config['MAIL_DEFAULT_SENDER'] = 'size.crm@gmail.com'
mail = Mail(application)

bcrypt = Bcrypt(application)
bot = telebot.TeleBot('')


@application.route('/', methods=['GET'])
def test():
    return 'SizeCRM API v1.0'


def decode_access_token(access_token, secret_key):
    try:
        payload = jwt.decode(access_token, secret_key, algorithms=['HS256'])
        return payload
    except jwt.ExpiredSignatureError:
        # Handle expired token
        return None
    except jwt.InvalidTokenError:
        # Handle invalid token
        return None


def decode_refresh_token(refresh_token, secret_key):
    try:
        payload = jwt.decode(refresh_token, secret_key, algorithms=['HS256'])
        return payload
    except jwt.ExpiredSignatureError:
        # Handle expired token
        return None
    except jwt.InvalidTokenError:
        # Handle invalid token
        return None


# Sample function to verify access token
def verify_access_token(access_token):
    try:
        decoded_token = decode_access_token(access_token, SECRET_KEY)
        if decoded_token:
            user_id = decoded_token.get('user_id')
            # Fetch user data from the database using the user_id
            user = users_collection.find_one({'_id': ObjectId(user_id)})
            if user:
                name = user['name']
                userpic = user['userpic']
                role = user['role']
                email = user['email']
                return jsonify({'user_id': user_id, 'name': name, 'userpic': userpic, 'role': role,
                                'email': email}), 200
            # User is authenticated, proceed with processing the request
            else:
                return jsonify({'message': 'User not found'}), 404
        # User not found, handle the error
    except jwt.ExpiredSignatureError:
        # Token has expired
        return False
    except jwt.InvalidTokenError:
        # Invalid token
        return False


# Sample function to verify refresh token
def verify_refresh_token(refresh_token):
    try:
        decoded_token = decode_refresh_token(refresh_token, SECRET_KEY)
        if decoded_token:
            user_id = decoded_token.get('user_id')
            # Fetch user data from the database using the user_id
            user = users_collection.find_one({'_id': ObjectId(user_id)})
            if user:
                name = user['name']
                userpic = user['userpic']
                return jsonify({'name': name, 'userpic': userpic}), 200
            # User is authenticated, proceed with processing the request
            else:
                return jsonify({'message': 'User not found'}), 404
        # User not found, handle the error
    except jwt.ExpiredSignatureError:
        # Token has expired
        return False
    except jwt.InvalidTokenError:
        # Invalid token
        return False


def check_token(access_token):
    if not access_token:
        response = jsonify({'token': False}), 401
        return False
    try:
        # Verify the JWT token
        decoded_token = jwt.decode(access_token, SECRET_KEY, algorithms=['HS256'])
        return True
    except jwt.ExpiredSignatureError:
        response = jsonify({'token': False}), 401
        return False
    except jwt.InvalidTokenError:
        response = jsonify({'token': False}), 401
        return False


@application.route('/validate_tokens', methods=['POST'])
def validate_tokens():
    data = request.get_json()
    access_token = data.get('access_token')
    refresh_token = data.get('refresh_token')

    if not access_token and not refresh_token:
        response = jsonify({'message': 'Access token or refresh token is missing'}), 401
        return response

    if access_token:
        return verify_access_token(access_token)
    if refresh_token:
        return verify_refresh_token(refresh_token)


# Endpoint for user login
@application.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    email = data.get('email')
    password = data.get('password')
    remember_me = data.get('remember_me', False)  # Assuming remember_me is a boolean field in the request

    # Check if the user exists in the database
    user = users_collection.find_one({'email': email})

    if user:
        hashed_password_in_db = user.get('password', '')  # Assuming the field name is 'password'

        if bcrypt.check_password_hash(hashed_password_in_db, password):
            user_id = str(user['_id'])  # Assuming user ID is stored as ObjectId in MongoDB

            # Set expiration time based on remember_me
            if remember_me:
                expiration_time = datetime.utcnow() + timedelta(days=1)
            else:
                expiration_time = datetime.utcnow() + timedelta(minutes=30)

            # Generate tokens based on user ID
            access_token = jwt.encode(
                {'user_id': user_id, 'exp': expiration_time},
                application.config['SECRET_KEY'], algorithm='HS256')

            # Save user's email if remember_me is checked
            if remember_me:
                session.permanent = True
                session['user_email'] = email
                session['user_password'] = password

            response = jsonify({'access_token': access_token}), 200
            return response

    response = jsonify({'message': False}), 401
    return response


# Endpoint for user registration
@application.route('/register', methods=['POST'])
def register():
    default_userpic = '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AQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFAAAQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFAAAQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFAAAQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFAAAQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFAAAQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFAAAQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFAAAQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFAAAQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFAAAQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFAAAQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFAAAQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFAAAQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFAAAQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFAAAQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFAAAQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFAAAQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFAAAQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFAAAQAAAAAAAAAAFEAAAAAAAAAAAAAFEAAAAAAAAAAAQAEEAAAAAAAAAABQAAEAAAAAAAAAABRAAAAAAAAAAAAABRAAAAAAAAAAAEABBAAAAAAAAAAAUAABAAAAAAAAAAAUQAAAAAAAAAAAAAUQAAAAAAAAAABAAQQAAAAAAAAAAFCAhgmgC0fyV3I9rjMEAAAAAABA/6VW/ooVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWLr/ByoQG66/q4OlAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIyLTA2LTIxVDIwOjAwOjQ4KzAwOjAwk48hBwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMi0wNi0yMVQyMDowMDo0OCswMDowMOLSmbsAAAAASUVORK5CYII='
    data = request.get_json()
    name = data.get('name')
    phone = data.get('phone')
    email = data.get('email')
    password = data.get('password')
    password2 = data.get('password2')

    if password != password2:
        return ({'message': False}), 409

    # Hash the password using bcrypt
    hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')

    document = {
        'name': name,
        'phone': phone,
        'email': email,
        'password': hashed_password,
        'password2': hashed_password,
        'userpic': default_userpic,
        'role': 'all',
        'subscription': True,
        'subscription_end': datetime.today() + timedelta(days=30)
    }

    is_present = users_collection.find_one({'email': email})

    if (is_present is None) and (bcrypt.check_password_hash(hashed_password, password)):
        users_collection.insert_one(document)
        response = jsonify({'message': True}), 200
        return response
    else:
        response = jsonify({'message': False}), 401
        return response


@application.route('/demo_register', methods=['POST'])
def demo_register():
    # Replace with your GitHub PDF link
    github_pdf_link = 'https://github.com/bagriul/sizecrm/blob/main/presentation_size.pdf'

    # Download PDF from GitHub
    pdf_response = requests.get(github_pdf_link)
    pdf_data = BytesIO(pdf_response.content)

    # Create Flask-Mail message
    subject = 'Презентація СРМ для вашого бізнесу'
    sender_email = 'size.crm@gmail.com'
    data = request.get_json()
    to_email = data.get('email')
    message_body = ''

    msg = Message(subject, sender=sender_email, recipients=[to_email])
    msg.body = message_body
    pdf_data.seek(0)
    msg.attach('presentation_size.pdf', 'application/pdf', pdf_data.getvalue())

    # Send the email
    try:
        mail.send(msg)
        name = data.get('name')
        phone = data.get('phone')
        brand = data.get('brand')
        position = data.get('position')
        document = {'name': name,
                    'phone': phone,
                    'brand': brand,
                    'position': position,
                    'email': to_email}
        is_present = demo_users_collection.find_one(document)
        if is_present is None:
            demo_users_collection.insert_one(document)
        return 'Email sent successfully!'
    except Exception as e:
        return f'Error sending email: {str(e)}'


def generate_random_credentials():
    username = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
    password = ''.join(random.choices(string.ascii_letters + string.digits + string.punctuation, k=12))
    return username, password


def check_credentials_exist(username, password):
    existing_user = users_collection.find_one({'username': username, 'password': password})
    return existing_user is not None


def generate_tokens(user_id):
    access_token_payload = {
        'user_id': user_id,
        'exp': datetime.utcnow() + timedelta(minutes=30)  # Token expires in 30 minutes
    }
    access_token = jwt.encode(access_token_payload, SECRET_KEY, algorithm='HS256')

    refresh_token_payload = {
        'user_id': user_id,
        'exp': datetime.utcnow() + timedelta(days=30)  # Token expires in 30 days
    }
    refresh_token = jwt.encode(refresh_token_payload, SECRET_KEY, algorithm='HS256')

    return access_token, refresh_token


@application.route('/temporary_user_register', methods=['POST'])
def temporary_user_register():
    # Generate random username and password
    username, password = generate_random_credentials()

    # Check if credentials already exist
    while check_credentials_exist(username, password):
        username, password = generate_random_credentials()

    # Hash the password using bcrypt
    hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')

    # Insert user data into the database
    document = {
        'username': username,
        'password': hashed_password,
        'type': 'temporary'
    }
    users_collection.insert_one(document)

    # Generate access and refresh tokens
    access_token, refresh_token = generate_tokens(username)  # You can use username as user_id here

    # Return access and refresh tokens
    return jsonify({'access_token': access_token, 'refresh_token': refresh_token}), 200


@application.route('/temporary_user_delete', methods=['POST'])
def temporary_user_delete():
    data = request.get_json()
    access_token = data.get('access_token')
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    deleted_count = 0
    for collection_name in db.list_collection_names():
        collection = db[collection_name]
        result = collection.delete_many({'user_id': user_id})
        deleted_count += result.deleted_count

    # Delete the user
    users_collection.delete_one({'username': user_id})

    return jsonify({'message': True}), 200


def generate_token():
    return ''.join(random.choices(string.ascii_letters + string.digits, k=20))


@application.route('/forgot_password', methods=['POST'])
def forgot_password():
    data = request.get_json()
    email = data.get('email')

    user = users_collection.find_one({'email': email})
    if user:
        token = generate_token()
        users_collection.update_one({'email': email}, {'$set': {'reset_token': token}})

        msg = Message('Відновлення паролю', recipients=[email])
        msg.body = f"Перейдіть за цим посиланням для відновлення паролю: http://127.0.0.1:5000/reset_password?token={token}"
        mail.send(msg)

        return jsonify({'message': True}), 200
    else:
        return jsonify({'message': False}), 404


@application.route('/reset_password', methods=['POST'])
def reset_password():
    data = request.get_json()
    token = data.get('reset_token')
    new_password = data.get('new_password')

    user = users_collection.find_one({'reset_token': token})
    if user:
        hashed_password = bcrypt.generate_password_hash(new_password).decode('utf-8')
        users_collection.update_one({'reset_token': token}, {'$set': {'password': hashed_password, 'reset_token': None}})

        return jsonify({'message': True}), 200
    else:
        return jsonify({'message': False}), 400


@application.route('/check_reset_token', methods=['POST'])
def check_reset_token():
    data = request.get_json()
    token = data.get('reset_token')

    user = users_collection.find_one({'reset_token': token})
    if user:
        return jsonify({'message': True}), 200
    else:
        return jsonify({'message': False}), 400


def send_welcome_email(email):
    msg = Message('Презентація СРМ для вашого бізнесу', recipients=[email])

    # Customize the email content
    msg.body = ''

    pdf_file_url = 'https://raw.githubusercontent.com/bagriul/sizecrm/main/%D0%9F%D1%80%D0%B5%D0%B7%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D1%96%D1%8F%20Size%20CRM.pdf'

    # Download the PDF file from the URL
    response = requests.get(pdf_file_url)

    # Attach the PDF file to the email
    msg.attach('%D0%9F%D1%80%D0%B5%D0%B7%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D1%96%D1%8F%20Size%20CRM.pdf', 'application/pdf', response.content)

    mail.send(msg)


# Endpoint to add new client
@application.route('/add_client', methods=['POST'])
def add_client():
    # Get form data including image
    data = request.form.to_dict()
    userpic = request.files.get('userpic')

    # Check access token
    access_token = data.get('access_token')
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    # Extract data from form
    name = data.get('name')
    phone = data.get('phone')
    additional_phone = data.get('additional_phone')
    email = data.get('email')
    gender = data.get('gender')
    birthday = data.get('birthday')
    instagram = data.get('instagram')
    telegram = data.get('telegram')
    comment = data.get('comment')
    status = data.get('status')
    discount = data.get('discount', 0)

    # Fetch status document from collection
    status_doc = statuses_collection.find_one({'status': status}, {'_id': 0}) if status else None

    # Process image file
    userpic = base64.b64encode(userpic.read()).decode('utf-8') if userpic else None

    # Construct document
    document = {
        'name': name,
        'phone': phone,
        'additional_phone': additional_phone,
        'email': email,
        'gender': gender,
        'birthday': datetime.strptime(birthday, "%a %b %d %Y"),
        'instagram': instagram,
        'telegram': telegram,
        'comment': comment,
        'status': status_doc,
        'userpic': userpic,
        'user_id': user_id,
        'discount': discount
    }

    # Check if client already exists
    is_present = clients_collection.find_one({'email': email, 'user_id': user_id})
    if is_present:
        return jsonify({'message': 'Client already exists'}), 409

    # Insert new client document
    clients_collection.insert_one(document)

    # Return response
    return jsonify({'message': 'Client created successfully'}), 200


# Endpoint to get clients list
@application.route('/clients', methods=['POST'])
def clients():
    # Get data from request
    data = request.get_json()

    # Get access token from data
    access_token = data.get('access_token')

    # Check access token
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    # Decode user_id from access token
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    # Get keyword, page, and per_page from data
    keyword = data.get('keyword')
    page = data.get('page', 1)  # Default to page 1 if not provided
    per_page = data.get('per_page', 10)  # Default to 10 items per page if not provided

    # Define filter criteria based on user_id and keyword
    filter_criteria = {'user_id': user_id}
    if keyword:
        regex_pattern = f'.*{re.escape(keyword)}.*'
        filter_criteria['name'] = {'$regex': regex_pattern, '$options': 'i'}

    # Count the total number of clients that match the filter criteria
    total_clients = clients_collection.count_documents(filter_criteria)

    # Calculate total pages
    total_pages = math.ceil(total_clients / per_page)

    # Paginate the query results using skip and limit, and apply filters
    skip = (page - 1) * per_page
    clients = list(clients_collection.find(filter_criteria).skip(skip).limit(per_page))

    # Prepare response clients with additional information
    response_clients = []
    for client in clients:
        client_orders = list(orders_collection.find({'email': client['email']}))
        client['orders'] = client_orders
        total_price_sum = sum(order.get('total_sum', 0) for order in client_orders)
        latest_order_date = max((order.get('date', datetime.min) for order in client_orders), default=None)
        client['_id'] = str(client['_id'])
        client['orders_amount'] = len(client_orders)
        client['total_price_sum'] = total_price_sum
        client['latest_order_date'] = latest_order_date
        response_clients.append(client)

    # Sort response clients based on sort_by and reverse_sort parameters
    sort_by = data.get('sort_by')
    if sort_by:
        reverse_sort = data.get('reverse_sort', False)
        if sort_by in ('latest_order_date', 'status'):
            response_clients = sorted(response_clients, key=lambda x: x.get(
                sort_by) or datetime.min if sort_by == 'latest_order_date' else x.get('status', {}).get('status', ''),
                                      reverse=reverse_sort)
        else:
            response_clients = sorted(response_clients, key=lambda x: x.get(sort_by, 0), reverse=reverse_sort)

    # Calculate the range of clients being displayed
    start_range = skip + 1
    end_range = min(skip + per_page, total_clients)

    # Serialize the response clients using json_util from pymongo and specify encoding
    response = Response(
        json_util.dumps({
            'clients': response_clients,
            'total_clients': total_clients,
            'start_range': start_range,
            'end_range': end_range,
            'total_pages': total_pages
        }, ensure_ascii=False).encode('utf-8'),
        content_type='application/json;charset=utf-8'
    )

    return response, 200


# Endpoint to delete client
@application.route('/delete_client', methods=['POST'])
def delete_client():
    # Get data from request
    data = request.get_json()

    # Extract client_id and access_token from data
    client_id = data.get('client_id')
    access_token = data.get('access_token')

    # Check access token
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    try:
        # Convert client_id to ObjectId type
        client_object_id = ObjectId(client_id)
    except:
        # Return error response if client_id is invalid
        return jsonify({'message': 'Invalid client ID'}), 400

    # Find and delete the document by its ObjectId
    result = clients_collection.delete_one({'_id': client_object_id})

    # Check if document is deleted successfully
    if result.deleted_count == 1:
        return jsonify({'message': 'Client deleted successfully'}), 200
    else:
        return jsonify({'message': 'Client not found'}), 404


# Endpoint to edit client
@application.route('/update_client/<client_id>', methods=['POST'])
def update_client(client_id):
    # Get form data and access token from request
    data = request.form.to_dict()
    access_token = data.get('access_token')

    # Check access token
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    try:
        # Convert client_id to ObjectId type
        client_object_id = ObjectId(client_id)
    except:
        # Return error response if client_id is invalid
        return jsonify({'message': 'Invalid client ID'}), 400

    # Retrieve the existing client document from MongoDB
    existing_client = clients_collection.find_one({'_id': client_object_id})

    if existing_client:
        # Update client fields if new data is provided in the request
        for field in ['name', 'phone', 'additional_phone', 'email', 'gender', 'birthday', 'instagram', 'telegram', 'comment', 'discount']:
            if field in data:
                existing_client[field] = data[field]

        # Update client status if provided in the request
        if 'status' in data:
            status_doc = statuses_collection.find_one({'status': data['status']})
            if status_doc:
                del status_doc['_id']
            existing_client['status'] = status_doc

        # Update userpic if a new userpic is provided in the request
        userpic = request.files.get('userpic')
        if userpic:
            existing_client['userpic'] = process_and_store_userpic(userpic)

        # Update the client document in MongoDB
        clients_collection.replace_one({'_id': client_object_id}, existing_client)

        return jsonify({'message': 'Client updated successfully'}), 200

    else:
        return jsonify({'message': 'Client not found'}), 404

def process_and_store_userpic(userpic):
    try:
        # Read the image file as binary data
        image_data = userpic.read()

        # Encode the binary image data as base64
        base64_image = base64.b64encode(image_data).decode('utf-8')

        # Return the base64 encoded image data for MongoDB storage
        return base64_image

    except Exception as e:
        # Handle any potential errors while processing the image
        print(f"Error processing image: {str(e)}")
        return None


# Endpoint to create new client status
@application.route('/new_status', methods=['POST'])
def new_status():
    # Get data from request
    data = request.get_json()

    # Extract access_token and status details from data
    access_token = data.get('access_token')
    status = data.get('status')
    colour = data.get('colour')
    type = data.get('type')

    # Check access token
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    # Decode user_id from access token
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    # Check if status already exists
    is_present = statuses_collection.find_one({'status': status, 'type': type, 'user_id': user_id})
    if is_present:
        return jsonify({'message': 'Status already exists'}), 409

    # Insert new status document
    statuses_collection.insert_one({'status': status, 'colour': colour, 'type': type, 'user_id': user_id})

    return jsonify({'message': 'Created successfully'}), 200


@application.route('/get_statuses', methods=['POST'])
def get_statuses():
    # Get data from request
    data = request.get_json()

    # Extract access_token and type from data
    access_token = data.get('access_token')
    type = data.get('type')

    # Check access token
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    # Decode user_id from access token
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    # Prepare filter criteria based on user_id and type
    filter_criteria = {
        '$or': [
            {'user_id': user_id},
            {'user_id': "0"}
        ]
    }
    if type:
        filter_criteria['type'] = type

    # Retrieve documents from the collection based on filter criteria
    documents = list(statuses_collection.find(filter_criteria))

    # Convert ObjectId to string for each document
    for document in documents:
        document['_id'] = str(document['_id'])

    # Serialize the response documents using json_util from pymongo and specify encoding
    response = Response(
        json_util.dumps({'statuses': documents}, ensure_ascii=False).encode('utf-8'),
        content_type='application/json;charset=utf-8'
    )

    return response, 200


@application.route('/client_info', methods=['POST'])
def client_info():
    # Get data from request
    data = request.get_json()

    # Extract access_token and client_id from data
    access_token = data.get('access_token')
    client_id = data.get('client_id')

    # Check access token
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    # Convert client_id to ObjectId
    try:
        object_id = ObjectId(client_id)
    except:
        return jsonify({'message': 'Invalid client ID'}), 400

    # Find client document by ObjectId
    client_document = clients_collection.find_one({'_id': object_id})

    if client_document:
        # Convert ObjectId to string for client document
        client_document['_id'] = str(client_document['_id'])

        # Find orders where email matches client email
        client_email = client_document.get('email')
        orders_query = {'email': client_email}

        # Get total number of orders
        total_orders = orders_collection.count_documents(orders_query)

        # Pagination parameters
        page = int(data.get('page', 1))
        page_size = int(data.get('per_page', 10))
        skip = (page - 1) * page_size

        # Retrieve a subset of orders based on pagination
        orders = list(orders_collection.find(orders_query).skip(skip).limit(page_size))

        # Convert ObjectId to string for each order document
        for order in orders:
            order['_id'] = str(order['_id'])

        # Get sorting parameters from the request
        sort_by = data.get('sort_by')
        if sort_by:
            reverse_sort = data.get('reverse_sort', False)
            orders = sorted(orders, key=lambda x: x.get(sort_by, 0), reverse=reverse_sort)

        # Add sorted orders to the client document
        client_document['orders'] = orders

        # Calculate pagination details
        start_range = skip + 1
        end_range = min(skip + page_size, total_orders)
        total_pages = (total_orders + page_size - 1) // page_size

        # Include pagination details in the response
        response_data = {
            'client_info': client_document,
            'total_orders': total_orders,
            'start_range': start_range,
            'end_range': end_range,
            'total_pages': total_pages
        }

        # Serialize response data using json.dumps() with ObjectId serialization
        return json.dumps(response_data, default=str), 200, {'Content-Type': 'application/json'}
    else:
        return jsonify({'message': 'Client not found'}), 404


# Endpoint to get orders list
@application.route('/orders', methods=['POST'])
def orders():
    # Get data from request
    data = request.get_json()

    # Extract access_token and user_id from data
    access_token = data.get('access_token')
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    # Check access token
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    # Extract filtering parameters from data
    keyword = data.get('keyword')
    page = data.get('page', 1)  # Default to page 1 if not provided
    per_page = data.get('per_page', 10)  # Default to 10 items per page if not provided

    # Prepare filter criteria
    filter_criteria = {'user_id': user_id}
    if keyword:
        regex_pattern = f'.*{re.escape(keyword)}.*'
        filter_criteria['name'] = {'$regex': regex_pattern, '$options': 'i'}

    # Count the total number of orders that match the filter criteria
    total_orders = orders_collection.count_documents(filter_criteria)
    total_pages = math.ceil(total_orders / per_page)

    # Paginate the query results using skip and limit, and apply filters
    skip = (page - 1) * per_page
    documents = list(orders_collection.find(filter_criteria).skip(skip).limit(per_page))

    # Convert ObjectId to string and format date for each document
    for document in documents:
        document['_id'] = str(document['_id'])
        document['date'] = document['date'].strftime("%a %b %d %Y")

    # Sort documents based on sort_by parameter
    sort_by = data.get('sort_by')
    if sort_by:
        reverse_sort = data.get('reverse_sort', False)
        if sort_by == 'date':
            documents = sorted(documents, key=lambda x: x.get('date', ''), reverse=reverse_sort)
        elif sort_by in ('client', 'status', 'source', 'payment'):
            documents = sorted(documents, key=lambda x: x.get(sort_by, ''), reverse=reverse_sort)

    # Calculate the range of orders being displayed
    start_range = skip + 1
    end_range = min(skip + per_page, total_orders)

    # Serialize the documents using json_util from pymongo and specify encoding
    response = Response(
        json_util.dumps({
            'orders': documents,
            'total_orders': total_orders,
            'start_range': start_range,
            'end_range': end_range,
            'total_pages': total_pages
        }, ensure_ascii=False).encode('utf-8'),
        content_type='application/json;charset=utf-8'
    )
    return response, 200


@application.route('/add_order', methods=['POST'])
def add_order():
    data = request.get_json()

    # Check access token
    access_token = data.get('access_token')
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    # Extract order details from request data
    client_name = data.get('client')
    client_email = data.get('email')
    shipping = data.get('shipping')
    status = data.get('status')
    source = data.get('source')
    payment = data.get('payment')
    comment = data.get('comment')
    cashier = data.get('cashier')
    variations_data = data.get('variations', [])

    # Get client details
    client = clients_collection.find_one({'name': client_name, 'email': client_email})

    # Prepare variations list
    variations = []
    total_sum = 0
    in_stock_errors = []

    for var_data in variations_data:
        variation_id = var_data.get('id')
        amount = var_data.get('amount', 1)  # Default amount is 1 if not specified

        # Fetch product and its variation
        product = products_collection.find_one({'variations._id': variation_id})

        if product:
            for variation in product.get('variations', []):
                if variation.get('_id') == variation_id:
                    variation_data = {
                        '_id': variation.get('_id'),
                        'name': product.get('name'),
                        'category': product.get('category'),
                        'size': variation.get('size'),
                        'colour': variation.get('colour'),
                        'price': variation.get('price'),
                        'in_stock': variation.get('in_stock'),
                        'photos': variation.get('photos'),
                        'cost_price': variation.get('cost_price'),
                        'amount': amount
                    }

                    if variation_data['in_stock'] < amount:
                        in_stock_errors.append({
                            'variation_id': variation_data['_id'],
                            'error': f'Not enough stock. Available: {variation_data["in_stock"]}'
                        })
                    else:
                        variations.append(variation_data)

                        try:
                            # Calculate price considering loyalty and client discounts
                            loyalty = loyalty_collection.find_one({'user_id': user_id, 'category': product.get('category'),
                                                                   'date': datetime.utcnow().replace(hour=0, minute=0,
                                                                                                     second=0,
                                                                                                     microsecond=0)})
                            if loyalty is not None:
                                variation_data['price'] = (variation_data['price'] * (100 - loyalty['discount']) / 100)
                            elif client['discount'] != 0:
                                variation_data['price'] = (variation_data['price'] * (100 - client['discount']) / 100)
                        except KeyError:
                            pass

                        # Calculate total sum for this variation
                        total_sum += variation_data['price'] * amount

                        # Update in_stock for this variation
                        variation_in_stock = variation.get('in_stock', 0) - amount
                        products_collection.update_one(
                            {'variations._id': variation_id},
                            {'$set': {'variations.$.in_stock': max(0, variation_in_stock)}}
                        )

    if in_stock_errors:
        return jsonify({'errors': in_stock_errors}), 400

    # Apply global discounts
    discount_sum = data.get('discount_sum', 0)
    discount_per = data.get('discount_per', 0)
    total_sum -= discount_sum
    total_sum -= (total_sum * discount_per / 100)

    # Prepare order document
    order_doc = {
        'date': datetime.today(),
        'client': client,
        'email': client_email,
        'gender': client.get('gender'),
        'shipping': shipping,
        'status': statuses_collection.find_one({'status': status}, {'_id': 0}),
        'source': source,
        'payment': payment,
        'comment': comment,
        'variations': variations,
        'discount_sum': discount_sum,
        'discount_per': discount_per,
        'total_sum': total_sum,
        'cashier': cashier,
        'user_id': user_id
    }

    # Check if order already exists
    existing_order = orders_collection.find_one(order_doc)
    if existing_order is None:
        new_order = orders_collection.insert_one(order_doc)

        notification = {'text': 'Нове замовлення', 'user_id': user_id}
        notifications_collection.insert_one(notification)

        # Process payment if status is 'Оплачено'
        if status == 'Оплачено':
            cashier = cashiers_collection.find_one({'name': cashier, 'user_id': user_id})
            balance = cashier.get('balance', 0)
            incomes = cashier.get('incomes', 0)
            cashiers_collection.update_one({'_id': cashier['_id']}, {'$set': {'balance': balance + total_sum}})
            cashiers_collection.update_one({'_id': cashier['_id']}, {'$set': {'incomes': incomes + total_sum}})
            transaction = {
                'type': "На рахунок",
                'cashier': cashier['name'],
                'sum': total_sum,
                'counterpartie': '',
                'date': datetime.now(),
                'category': '',
                'comment': '',
                'user_id': user_id,
                'order_id': str(new_order.inserted_id)
            }
            transactions_collection.insert_one(transaction)

            notification = {'text': 'Нове оплачене замовлення', 'user_id': user_id}
            notifications_collection.insert_one(notification)

    return jsonify({'message': True}), 200


@application.route('/delete_order', methods=['POST'])
def delete_order():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401

    order_id = data.get('order_id')
    orders_collection.find_one_and_delete({'_id': ObjectId(order_id)})
    return jsonify({'message': True}), 200


@application.route('/update_order', methods=['POST'])
def update_order():
    data = request.get_json()

    # Check access token
    access_token = data.get('access_token')
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    order_id = data.get('order_id')
    order = orders_collection.find_one({'_id': ObjectId(order_id)})
    total_sum = order.get('total_sum')
    if order is None:
        return jsonify({'message': False}), 404

    client_email = order.get('email')
    client = clients_collection.find_one({'email': client_email})
    try:
        client_discount = client['discount']
    except KeyError:
        client_discount = 0
    except TypeError:
        client_discount = 0

    # Update other order fields if provided
    order['client'] = data.get('client', order.get('client'))
    order['email'] = data.get('email', order.get('email'))
    order['shipping'] = data.get('shipping', order.get('shipping'))
    order['status'] = statuses_collection.find_one({'status': data.get('status')}, {'_id': 0}) if 'status' in data else order.get('status')
    order['source'] = data.get('source', order.get('source'))
    order['payment'] = data.get('payment', order.get('payment'))
    order['comment'] = data.get('comment', order.get('comment'))
    order['cashier'] = data.get('cashier', order.get('cashier'))

    # Prepare variations list
    variations_data = data.get('variations', [])
    if variations_data:
        variations = []
        total_sum = 0

        for var_data in variations_data:
            variation_id = var_data.get('id')
            amount = var_data.get('amount', 1)  # Default amount is 1 if not specified

            # Fetch product and its variation
            product = products_collection.find_one({'variations._id': variation_id})

            if product:
                for variation in product.get('variations', []):
                    if variation.get('_id') == variation_id:
                        variation_data = {
                            '_id': variation.get('_id'),
                            'name': product.get('name'),
                            'category': product.get('category'),
                            'size': variation.get('size'),
                            'colour': variation.get('colour'),
                            'price': variation.get('price'),
                            'in_stock': variation.get('in_stock'),
                            'photos': variation.get('photos'),
                            'cost_price': variation.get('cost_price'),
                            'amount': amount
                        }
                        variations.append(variation_data)

                        try:
                            # Calculate price considering loyalty and client discounts
                            loyalty = loyalty_collection.find_one(
                                {'user_id': user_id, 'category': product.get('category'),
                                 'date': datetime.utcnow().replace(hour=0, minute=0,
                                                                   second=0,
                                                                   microsecond=0)})
                            if loyalty is not None:
                                variation_data['price'] = (variation_data['price'] * (100 - loyalty['discount']) / 100)
                            elif client_discount != 0:
                                variation_data['price'] = (variation_data['price'] * (100 - client_discount) / 100)
                        except KeyError:
                            pass

                        # Calculate total sum for this variation
                        total_sum += variation_data['price'] * amount

                        # Update in_stock for this variation
                        variation_in_stock = variation.get('in_stock', 0) - amount
                        products_collection.update_one(
                            {'variations._id': variation_id},
                            {'$set': {'variations.$.in_stock': max(0, variation_in_stock)}}
                        )

    # Apply global discounts
    discount_sum = data.get('discount_sum', 0)
    discount_per = data.get('discount_per', 0)
    print(total_sum)
    try:
        if discount_sum != 0:
            total_sum -= discount_sum
    except TypeError:
        pass
    try:
        if discount_per != 0:
            total_sum -= (total_sum * discount_per / 100)
    except TypeError:
        pass

    # Update order document
    if variations_data:
        order['variations'] = variations
    order['discount_sum'] = discount_sum
    order['discount_per'] = discount_per
    order['total_sum'] = total_sum

    orders_collection.update_one({'_id': ObjectId(order_id)}, {'$set': order})

    # Process payment if status is 'Оплачено' or 'Повернено'
    if data.get("status") in ['Оплачено', 'Повернено']:
        cashier = cashiers_collection.find_one({'name': order.get('cashier'), 'user_id': user_id})
        if cashier:
            balance = cashier.get('balance', 0)
            incomes = cashier.get('incomes', 0)
            # Update balance and incomes based on status
            if data.get("status") == 'Оплачено':
                new_balance = balance + total_sum
                new_incomes = incomes + total_sum
                cashiers_collection.update_one({'_id': cashier['_id']},
                                               {'$set': {'balance': new_balance, 'incomes': new_incomes}})
            elif data.get("status") == 'Повернено':
                new_balance = balance - total_sum
                new_incomes = incomes - total_sum
                cashiers_collection.update_one({'_id': cashier['_id']},
                                               {'$set': {'balance': new_balance, 'incomes': new_incomes}})

            # Record the transaction
            transaction = {
                'type': "На рахунок" if data.get("status") == 'Оплачено' else "З рахунку",
                'cashier': cashier['name'],
                'sum': total_sum,
                'counterpartie': '',
                'date': datetime.now(),
                'category': '',
                'comment': '',
                'user_id': user_id,
                'order_id': str(order_id)
            }
            transactions_collection.insert_one(transaction)

            # Create a notification
            notification_text = 'Нове оплачене замовлення' if data.get(
                "status") == 'Оплачено' else 'Повернене замовлення'
            notification = {'text': notification_text, 'user_id': user_id}
            notifications_collection.insert_one(notification)

    return jsonify({'message': True}), 200


@application.route('/add_product_order', methods=['POST'])
def add_product_order():
    data = request.get_json()

    # Check access token
    access_token = data.get('access_token')
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    order_id = data.get('order_id')
    order = orders_collection.find_one({'_id': ObjectId(order_id)})
    if order is None:
        return jsonify({'message': False}), 404

    variation_id = data.get('variation_id')
    products_id_list = [str(product['_id']) for product in order.get('products', [])]

    if variation_id in products_id_list:
        for product in order['products']:
            if str(product['_id']) == variation_id:
                product['amount'] += 1
                break
    else:
        variation = variations_collection.find_one({'_id': ObjectId(variation_id)})
        if variation:
            document = {
                '_id': variation['_id'],
                'size': variation['size'],
                'colour': variation['colour'],
                'price': variation['price'],
                'in_stock': variation['in_stock'],
                'amount': 1,
                'photos': variation['photos'],
                'name': variation['name']
            }
            orders_collection.update_one({'_id': ObjectId(order_id)}, {'$push': {'products': document}})

    # Recalculate total_sum and update it in the order document
    order = orders_collection.find_one({'_id': ObjectId(order_id)})
    total_sum = sum(product['price'] * product['amount'] for product in order.get('products', []))
    orders_collection.update_one({'_id': ObjectId(order_id)}, {'$set': {'total_sum': total_sum}})

    return jsonify({'message': True}), 200


@application.route('/delete_product_order', methods=['POST'])
def delete_product_order():
    data = request.get_json()

    # Check access token
    access_token = data.get('access_token')
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    order_id = data.get('order_id')
    order = orders_collection.find_one({'_id': ObjectId(order_id)})
    if order is None:
        return jsonify({'message': False}), 404

    variation_id = data.get('variation_id')

    # Try to remove the product from the order
    try:
        orders_collection.update_one(order, {'$pull': {'products': {'_id': ObjectId(variation_id)}}})
    except:
        # If removing by ObjectId fails, try removing by string ID
        orders_collection.update_one(order, {'$pull': {'products': {'_id': variation_id}}})

    # Recalculate total_sum and update it in the order document
    order = orders_collection.find_one({'_id': ObjectId(order_id)})
    total_sum = sum(product['price'] * product['amount'] for product in order.get('products', []))
    orders_collection.find_one_and_update(order, {'$set': {'total_sum': total_sum}})

    return jsonify({'message': True}), 200


def convert_object_id(obj):
    if isinstance(obj, list):
        return [convert_object_id(item) for item in obj]
    elif isinstance(obj, dict):
        return {key: convert_object_id(value) for key, value in obj.items()}
    elif isinstance(obj, ObjectId):
        return str(obj)
    else:
        return obj

@application.route('/order_info', methods=['POST'])
def order_info():
    data = request.get_json()

    # Check access token
    access_token = data.get('access_token')
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    order_id = data.get('order_id')
    object_id = ObjectId(order_id)

    # Find the order document by its ObjectId
    order_document = orders_collection.find_one({'_id': object_id})

    if order_document:
        # Convert ObjectId to string and format date before returning the response
        order_document = convert_object_id(order_document)
        order_document['date'] = order_document['date'].strftime("%a %b %d %Y")

        # Return the order document as JSON with proper content type
        return jsonify(order_document), 200, {'Content-Type': 'application/json'}
    else:
        # Return a 404 response if the order is not found
        return jsonify({'message': 'Order not found'}), 404



@application.route('/add_task', methods=['POST'])
def add_task():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')
    creator = data.get('creator')
    headline = data.get('headline')
    description = data.get('description', None)
    participants = data.get('participants', None)
    responsible = data.get('responsible', None)
    deadline = data.get('deadline', None)
    if deadline:
        deadline = datetime.strptime(deadline, "%a %b %d %Y")
    status = data.get('status', None)
    if status:
        status_doc = statuses_collection.find_one({'status': status})
        if status_doc:
            del status_doc['_id']
    comment = data.get('comment', None)

    # Get today's date
    today = datetime.today()

    document = {'date': today,
                'creator': creator,
                'headline': headline,
                'description': description,
                'participants': participants,
                'responsible': responsible,
                'deadline': deadline,
                'status': status_doc,
                'comment': comment,
                'user_id': user_id}
    tasks_collection.insert_one(document)

    notification = {'text': f'Нове завдання: {headline}. Дедлайн: {deadline}',
                    'user_id': user_id}
    notifications_collection.insert_one(notification)

    return jsonify({'message': True}), 200


@application.route('/update_task', methods=['POST'])
def update_task():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401

    task_id = data.get('task_id')
    task = tasks_collection.find_one({'_id': ObjectId(task_id)})
    if task is None:
        return jsonify({'message': False}), 404

    # Update task fields based on the provided data
    task['headline'] = data.get('headline', task['headline'])
    task['creator'] = data.get('creator', task['creator'])
    task['description'] = data.get('description', task['description'])
    task['participants'] = data.get('participants', task['participants'])
    task['responsible'] = data.get('responsible', task['responsible'])
    deadline = datetime.strptime(data.get('deadline'), "%a %b %d %Y")
    if deadline:
        task['deadline'] = deadline
    status = data.get('status')
    if status:
        status_doc = statuses_collection.find_one({'status': status})
        if status_doc:
            del status_doc['_id']
        task['status'] = status_doc
    task['comment'] = data.get('comment', task['comment'])

    # Update the task in the database
    tasks_collection.update_one({'_id': ObjectId(task_id)}, {'$set': task})
    return jsonify({'message': True}), 200


@application.route('/delete_task', methods=['POST'])
def delete_task():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401

    task_id = data.get('task_id')
    tasks_collection.find_one_and_delete({'_id': ObjectId(task_id)})
    return jsonify({'message': True}), 200


@application.route('/task_info', methods=['POST'])
def task_info():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401

    task_id = data.get('task_id')
    object_id = ObjectId(task_id)
    task_document = tasks_collection.find_one({'_id': object_id})

    if task_document:
        # Convert ObjectId to string before returning the response
        task_document['_id'] = str(task_document['_id'])
        task_document['deadline'] = task_document['deadline'].strftime("%a %b %d %Y")
        task_document['date'] = task_document['date'].strftime("%a %b %d %Y")


        # Use dumps() to handle ObjectId serialization
        return json.dumps(task_document, default=str), 200, {'Content-Type': 'application/json'}
    else:
        response = jsonify({'message': 'Task not found'}), 404
        return response


@application.route('/tasks', methods=['POST'])
def tasks():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')
    keyword = data.get('keyword')
    page = data.get('page', 1)  # Default to page 1 if not provided
    per_page = data.get('per_page', 10)  # Default to 10 items per page if not provided

    filter_criteria = {'user_id': user_id}
    if keyword:
        regex_pattern = f'.*{re.escape(keyword)}.*'
        filter_criteria['headline'] = {'$regex': regex_pattern, '$options': 'i'}

    # Count the total number of clients that match the filter criteria
    total_tasks = tasks_collection.count_documents(filter_criteria)

    total_pages = math.ceil(total_tasks / per_page)

    # Paginate the query results using skip and limit, and apply filters
    skip = (page - 1) * per_page
    documents = list(tasks_collection.find(filter_criteria).skip(skip).limit(per_page))
    for document in documents:
        document['_id'] = str(document['_id'])
        document['date'] = document['date'].strftime("%a %b %d %Y")
        document['deadline'] = document['deadline'].strftime("%a %b %d %Y")

    sort_by = data.get('sort_by')
    if sort_by:
        reverse_sort = data.get('reverse_sort', False)
        if sort_by == 'status':
            documents = sorted(documents, key=lambda x: x.get("status", {}).get("status", ""), reverse=reverse_sort)
        else:
            documents = sorted(documents, key=lambda x: x.get(sort_by, 0), reverse=reverse_sort)

    # Calculate the range of clients being displayed
    start_range = skip + 1
    end_range = min(skip + per_page, total_tasks)

    # Serialize the documents using json_util from pymongo and specify encoding
    response = Response(json_util.dumps(
        {'tasks': documents, 'total_tasks': total_tasks, 'start_range': start_range, 'end_range': end_range,
         'total_pages': total_pages},
        ensure_ascii=False).encode('utf-8'),
                        content_type='application/json;charset=utf-8')
    return response, 200


@application.route('/add_task_participant', methods=['POST'])
def add_task_participant():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401

    task_id = data.get('task_id')
    task = tasks_collection.find_one({'_id': ObjectId(task_id)})
    if task is None:
        return jsonify({'message': False}), 404
    participant = data.get('participant')
    tasks_collection.update_one(task, {'$push': {'participants': participant}})
    return jsonify({'message': True}), 200


@application.route('/delete_task_participant', methods=['POST'])
def delete_task_participant():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401

    task_id = data.get('task_id')
    task = tasks_collection.find_one({'_id': ObjectId(task_id)})
    if task is None:
        return jsonify({'message': False}), 404
    participant = data.get('participant')
    tasks_collection.update_one(task, {'$pull': {'participants': participant}})
    return jsonify({'message': True}), 200


@application.route('/users', methods=['POST'])
def users():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')
    keyword = data.get('keyword')
    page = data.get('page', 1)  # Default to page 1 if not provided
    per_page = data.get('per_page', 10)  # Default to 10 items per page if not provided

    filter_criteria = {'user_id': user_id}
    if keyword:
        users_collection.create_index([("$**", "text")])
        filter_criteria['$text'] = {'$search': keyword}

    # Count the total number of clients that match the filter criteria
    total_users = users_collection.count_documents(filter_criteria)

    total_pages = math.ceil(total_users / per_page)

    # Paginate the query results using skip and limit, and apply filters
    skip = (page - 1) * per_page
    documents = list(users_collection.find(filter_criteria).skip(skip).limit(per_page))
    for document in documents:
        document['_id'] = str(document['_id'])

    # Calculate the range of clients being displayed
    start_range = skip + 1
    end_range = min(skip + per_page, total_users)

    # Serialize the documents using json_util from pymongo and specify encoding
    response = Response(json_util.dumps(
        {'users': documents, 'total_users': total_users, 'start_range': start_range, 'end_range': end_range,
         'total_pages': total_pages},
        ensure_ascii=False).encode('utf-8'),
                        content_type='application/json;charset=utf-8')
    return response, 200


@application.route('/add_product', methods=['POST'])
def add_product():
    data = request.get_json()
    access_token = data.get('access_token')

    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    name = data.get('name')
    description = data.get('description')
    status = data.get('status')
    type = data.get('status_type')

    if status:
        status_doc = statuses_collection.find_one({'status': status, 'type': type})
        if status_doc:
            del status_doc['_id']

    category = data.get('category')
    units = data.get('units')
    warehouse = data.get('warehouse')
    comment = data.get('comment')
    variations = data.get('variations')
    subwarehouse = data.get('subwarehouse')
    cost_price = data.get('cost_price')
    photo = data.get('photo')

    # Generate a unique ID for each variation
    for variation in variations:
        variation['_id'] = str(uuid4())

    # Check if the generated IDs already exist in the database
    existing_ids = set(product['_id'] for product in products_collection.find({}, {'_id': 1}))
    for variation in variations:
        while variation['_id'] in existing_ids:
            # Regenerate the ID until it's unique
            variation['_id'] = str(uuid4())

    pieces = sum(variation.get('in_stock', 0) for variation in variations)

    document = {
        'date': datetime.now(),
        'name': name,
        'description': description,
        'status': status_doc,
        'category': category,
        'units': units,
        'warehouse': warehouse,
        'subwarehouse': subwarehouse,
        'comment': comment,
        'variations': variations,
        'pieces': pieces,
        'variations_num': len(variations),
        'cost_price': cost_price,
        'photo': photo,
        'user_id': user_id
    }

    products_collection.insert_one(document)
    return jsonify({'message': True}), 200


@application.route('/products', methods=['POST'])
def products():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')
    keyword = data.get('keyword')
    warehouse = data.get('warehouse')
    subwarehouse = data.get('subwarehouse')
    page = data.get('page', 1)  # Default to page 1 if not provided
    per_page = data.get('per_page', 10)  # Default to 10 items per page if not provided

    filter_criteria = {'user_id': user_id}
    if keyword:
        regex_pattern = f'.*{re.escape(keyword)}.*'
        filter_criteria['name'] = {'$regex': regex_pattern, '$options': 'i'}
    if warehouse:
        regex_pattern = f'.*{re.escape(warehouse)}.*'
        filter_criteria['warehouse'] = {'$regex': regex_pattern, '$options': 'i'}
    if subwarehouse:
        regex_pattern = f'.*{re.escape(subwarehouse)}.*'
        filter_criteria['subwarehouse'] = {'$regex': regex_pattern, '$options': 'i'}

    total_products = products_collection.count_documents(filter_criteria)

    total_pages = math.ceil(total_products / per_page)

    skip = (page - 1) * per_page
    documents = list(products_collection.find(filter_criteria).skip(skip).limit(per_page))
    for document in documents:
        document['_id'] = str(document['_id'])
    for document in documents:
        for variation in document['variations']:
            variation['name'] = document['name']

    sort_by = data.get('sort_by')
    if sort_by:
        reverse_sort = data.get('reverse_sort', False)
        if sort_by == 'category':
            documents = sorted(documents, key=lambda x: x.get('category', ''), reverse=reverse_sort)
        elif sort_by == 'date':
            documents = sorted(documents, key=lambda x: x.get('date', ''),
                               reverse=reverse_sort)
        elif sort_by == 'warehouse':
            documents = sorted(documents, key=lambda x: x.get('warehouse', ''), reverse=reverse_sort)
        elif sort_by == 'pieces':
            documents = sorted(documents, key=lambda x: x.get('pieces', 0), reverse=reverse_sort)
        elif sort_by == 'status':
            documents = sorted(documents, key=lambda x: x.get('status', {}).get('status', ''), reverse=reverse_sort)

    start_range = skip + 1
    end_range = min(skip + per_page, total_products)

    response = Response(json_util.dumps(
        {'products': documents, 'total_products': total_products, 'start_range': start_range, 'end_range': end_range,
         'total_pages': total_pages},
        ensure_ascii=False).encode('utf-8'),
                        content_type='application/json;charset=utf-8')
    return response, 200


@application.route('/product_info', methods=['POST'])
def product_info():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401

    product_id = data.get('product_id')
    object_id = ObjectId(product_id)
    product_document = products_collection.find_one({'_id': object_id})

    if product_document:
        # Convert ObjectId to string before returning the response
        product_document['_id'] = str(product_document['_id'])

        # Include pagination details in the response
        response_data = {
            'product_info': product_document
        }

        # Use dumps() to handle ObjectId serialization
        return json.dumps(response_data, default=str), 200, {'Content-Type': 'application/json'}
    else:
        response = jsonify({'message': 'Product not found'}), 404
        return response


@application.route('/update_product', methods=['POST'])
def update_product():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401

    product_id = data.get('product_id')
    product = products_collection.find_one({'_id': ObjectId(product_id)})
    if product is None:
        return jsonify({'message': False}), 404

    # Update task fields based on the provided data
    product['name'] = data.get('name', product['name'])
    product['description'] = data.get('description', product['description'])
    status = data.get('status')
    type = data.get('status_type')
    if status:
        status_doc = statuses_collection.find_one({'status': status, 'type': type})
        if status_doc:
            del status_doc['_id']
        product['status'] = status_doc
    product['category'] = data.get('category', product['category'])
    product['units'] = data.get('units', product['units'])
    product['warehouse'] = data.get('warehouse', product['warehouse'])
    product['subwarehouse'] = data.get('subwarehouse', product['subwarehouse'])
    product['comment'] = data.get('comment', product['comment'])
    product['cost_price'] = data.get('cost_price', product['cost_price'])
    product['photo'] = data.get('photo', product['photo'])

    variations = data.get('variations')
    if variations:
        product['variations'] = variations
    else:
        product['variations'] = []
    products_collection.update_one({'_id': ObjectId(product_id)}, {'$set': product})

    product = products_collection.find_one({'_id': ObjectId(product_id)})
    pieces = 0
    for variation in product['variations']:
        pieces += variation['in_stock']
    products_collection.find_one_and_update(product, {'$set': {'pieces': pieces}})
    products_collection.find_one_and_update(product, {'$set': {'variations_num': len(variations)}})

    return jsonify({'message': True}), 200


@application.route('/delete_product', methods=['POST'])
def delete_product():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401

    product_id = data.get('product_id')
    products_collection.find_one_and_delete({'_id': ObjectId(product_id)})
    return jsonify({'message': True}), 200


'''@application.route('/add_variation', methods=['POST'])
def add_variation():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401

    product_id = data.get('product_id')
    product = products_collection.find_one({'_id': ObjectId(product_id)})
    if product is None:
        return jsonify({'message': False}), 404
    variation = data.get('variation')
    products_collection.update_one(product, {'$push': {'variations': variation}})
    product = products_collection.find_one({'_id': ObjectId(product_id)})
    products_collection.update_one(product, {'$set': {'pieces': sum(variation.get('in_stock', 0) for variation in product['variations'])}})
    product = products_collection.find_one({'_id': ObjectId(product_id)})
    products_collection.update_one(product, {'$set': {'variations_num': len(product['variations'])}})
    return jsonify({'message': True}), 200


@application.route('/delete_variation', methods=['POST'])
def delete_variation():
    data = request.get_json()
    product_id = data.get('product_id')
    index = data.get('index')

    product = products_collection.find_one({'_id': ObjectId(product_id)})
    # Update the document by pulling the element with the specified sequence number
    products_collection.update_one(
        {"_id": ObjectId(product_id)},
        {"$pull": {"variations": {"$eq": product['variations'][index]}}}
    )

    # Update pieces and variations_num after removing the variation
    product = products_collection.find_one({'_id': ObjectId(product_id)})
    pieces_sum = sum(variation.get('in_stock', 0) for variation in product['variations'])
    variations_num = len(product['variations'])

    products_collection.update_one(
        {"_id": ObjectId(product_id)},
        {"$set": {"pieces": pieces_sum, "variations_num": variations_num}}
    )

    return jsonify({'message': True}), 200


@application.route('/variations', methods=['POST'])
def variations():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    name = data.get('name')

    filter_criteria = {}
    if name:
        regex_pattern = f'.*{re.escape(name)}.*'
        filter_criteria['name'] = {'$regex': regex_pattern, '$options': 'i'}

    documents = list(variations_collection.find(filter_criteria))
    for document in documents:
        document['_id'] = str(document['_id'])

    # Serialize the documents using json_util from pymongo and specify encoding
    response = Response(json_util.dumps({'variations': documents}, ensure_ascii=False).encode('utf-8'),
            content_type='application/json;charset=utf-8')
    return response, 200'''


@application.route('/add_subwarehouse', methods=['POST'])
def add_subwarehouse():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')
    warehouse = data.get('warehouse')
    subwarehouse = data.get('subwarehouse')

    document = {'warehouse': warehouse,
                'subwarehouse': subwarehouse,
                'user_id': user_id}

    warehouses_collection.insert_one(document)
    return jsonify({'message': True}), 200


@application.route('/delete_subwarehouse', methods=['POST'])
def delete_subwarehouse():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    warehouse = data.get('warehouse')
    subwarehouse = data.get('subwarehouse')

    document = {'warehouse': warehouse,
                'subwarehouse': subwarehouse}

    warehouses_collection.delete_one(document)
    return jsonify({'message': True}), 200


@application.route('/subwarehouses', methods=['POST'])
def subwarehouses():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    filter_criteria = {'user_id': user_id}

    documents = list(warehouses_collection.find(filter_criteria))
    for document in documents:
        document['_id'] = str(document['_id'])

    # Serialize the documents using json_util from pymongo and specify encoding
    response = Response(json_util.dumps({'subwarehouses': documents}, ensure_ascii=False).encode('utf-8'),
            content_type='application/json;charset=utf-8')
    return response, 200


@application.route('/add_transaction', methods=['POST'])
def add_transaction():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    if data.get('recuring') == False:
        type = data.get('type')
        cashier = data.get('cashier')
        amount = data.get('sum')
        counterpartie = data.get('counterpartie')
        date = datetime.strptime(data.get('date'), "%a %b %d %Y")
        category = data.get('category')
        comment = data.get('comment')

        document = {
            'type': type,
            'cashier': cashier,
            'sum': amount,
            'counterpartie': counterpartie,
            'date': date,
            'category': category,
            'comment': comment,
            'user_id': user_id
        }

        transactions_collection.insert_one(document)

        cashier_doc = cashiers_collection.find_one({'name': cashier})

        if document['type'] == 'На рахунок':
            cashier_doc['incomes'] += amount
            cashiers_collection.find_one_and_update(
                {'name': cashier},
                {'$set': {'incomes': cashier_doc['incomes']}}
            )
        elif document['type'] == 'З рахунку':
            cashier_doc['expenses'] += amount
            cashiers_collection.find_one_and_update(
                {'name': cashier},
                {'$set': {'expenses': cashier_doc['expenses']}}
            )

        # Assuming you have an '_id' field in your document
        transactions_collection.find_one_and_update(
            {'_id': document['_id']},
            {'$set': {'total_left': cashier_doc['incomes'] - cashier_doc['expenses']}}
        )

        return jsonify({'message': True})
    elif data.get('recuring') == True:
        type = data.get('type')
        cashier = data.get('cashier')
        amount = data.get('sum')
        counterpartie = data.get('counterpartie')
        date = datetime.strptime(data.get('date'), "%a %b %d %Y")
        category = data.get('category')
        comment = data.get('comment')
        periodicity = data.get('periodicity')

        document = {
            'type': type,
            'cashier': cashier,
            'sum': amount,
            'counterpartie': counterpartie,
            'date': date,
            'category': category,
            'comment': comment,
            'periodicity': periodicity,
            'user_id': user_id
        }

        transactions_collection.insert_one(document)
        auto_transactions_collection.insert_one(document)

        cashier_doc = cashiers_collection.find_one({'name': cashier})

        if document['type'] == 'На рахунок':
            cashier_doc['incomes'] += amount
            cashiers_collection.find_one_and_update(
                {'name': cashier},
                {'$set': {'incomes': cashier_doc['incomes']}}
            )
        elif document['type'] == 'З рахунку':
            cashier_doc['expenses'] += amount
            cashiers_collection.find_one_and_update(
                {'name': cashier},
                {'$set': {'expenses': cashier_doc['expenses']}}
            )

        # Assuming you have an '_id' field in your document
        transactions_collection.find_one_and_update(
            {'_id': document['_id']},
            {'$set': {'total_left': cashier_doc['incomes'] - cashier_doc['expenses']}}
        )

        return jsonify({'message': True})


@application.route('/update_transaction', methods=['POST'])
def update_transaction():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401

    transaction_id = data.get('transaction_id')
    transaction = transactions_collection.find_one({'_id': ObjectId(transaction_id)})
    if transaction is None:
        return jsonify({'message': False}), 404

    # Update task fields based on the provided data
    transaction['type'] = data.get('type', transaction['type'])
    transaction['cashier'] = data.get('cashier', transaction['cashier'])
    transaction['sum'] = data.get('sum', transaction['sum'])
    transaction['counterpartie'] = data.get('counterpartie', transaction['counterpartie'])
    transaction['category'] = data.get('category', transaction['category'])
    transaction['comment'] = data.get('comment', transaction['comment'])
    transaction['date'] = datetime.strptime(data.get('date', transaction['date']), "%a %b %d %Y")

    # Update the task in the database
    transactions_collection.update_one({'_id': ObjectId(transaction_id)}, {'$set': transaction})

    cashier = cashiers_collection.find_one({'name': transaction['cashier']})
    transactions = transactions_collection.find({'cashier': transaction['cashier']})
    incomes = 0
    expenses = 0
    for transaction in transactions:
        if transaction['type'] == 'На рахунок':
            incomes += transaction['sum']
        if transaction['type'] == 'З рахунку':
            expenses += transaction['sum']
    cashiers_collection.find_one_and_update(cashier, {'$set': {'incomes': incomes}})
    cashiers_collection.find_one_and_update(cashier, {'$set': {'expenses': expenses}})

    return jsonify({'message': True}), 200


@application.route('/delete_transaction', methods=['POST'])
def delete_transaction():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401

    transaction_id = data.get('transaction_id')
    transaction = transactions_collection.find_one({'_id': ObjectId(transaction_id)})
    transactions_collection.find_one_and_delete({'_id': ObjectId(transaction_id)})

    cashier = cashiers_collection.find_one({'name': transaction['cashier']})
    transactions = transactions_collection.find({'cashier': transaction['cashier']})
    incomes = 0
    expenses = 0
    for transaction in transactions:
        if transaction['type'] == 'На рахунок':
            incomes += transaction['sum']
        if transaction['type'] == 'З рахунку':
            expenses += transaction['sum']
    cashiers_collection.find_one_and_update(cashier, {'$set': {'incomes': incomes}})
    cashiers_collection.find_one_and_update(cashier, {'$set': {'expenses': expenses}})

    return jsonify({'message': True}), 200


@application.route('/transactions', methods=['POST'])
def transactions():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    keyword = data.get('keyword')
    page = data.get('page', 1)  # Default to page 1 if not provided
    per_page = data.get('per_page', 10)  # Default to 10 items per page if not provided
    archived = data.get('archived', False)  # Default to False if not provided

    filter_criteria = {'user_id': user_id}
    if keyword:
        regex_pattern = f'.*{re.escape(keyword)}.*'
        filter_criteria['comment'] = {'$regex': regex_pattern, '$options': 'i'}

    if not archived:
        filter_criteria['archived'] = {'$ne': True}

    # Count the total number of transactions that match the filter criteria
    total_transactions = transactions_collection.count_documents(filter_criteria)

    total_pages = math.ceil(total_transactions / per_page)

    # Paginate the query results using skip and limit, and apply filters
    skip = (page - 1) * per_page
    documents = list(transactions_collection.find(filter_criteria).skip(skip).limit(per_page))
    for document in documents:
        document['_id'] = str(document['_id'])
        document['date'] = document['date'].strftime("%a %b %d %Y")

    # Sorting logic
    sort_by = data.get('sort_by')
    if sort_by:
        reverse_sort = data.get('reverse_sort', False)
        if sort_by == 'date':
            documents = sorted(documents, key=lambda x: datetime.strptime(x['date'], "%a %b %d %Y"), reverse=reverse_sort)
        else:
            documents = sorted(documents, key=lambda x: x.get(sort_by, 0), reverse=reverse_sort)

    # Calculate the range of transactions being displayed
    start_range = skip + 1
    end_range = min(skip + per_page, total_transactions)

    # Serialize the documents using json_util from pymongo and specify encoding
    response = Response(json_util.dumps(
        {'transactions': documents, 'total_transactions': total_transactions, 'start_range': start_range, 'end_range': end_range,
         'total_pages': total_pages},
        ensure_ascii=False).encode('utf-8'),
                        content_type='application/json;charset=utf-8')
    return response, 200


@application.route('/transaction_info', methods=['POST'])
def transaction_info():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401

    transaction_id = data.get('transaction_id')
    object_id = ObjectId(transaction_id)
    transaction_document = transactions_collection.find_one({'_id': object_id})

    if transaction_document:
        # Convert ObjectId to string before returning the response
        transaction_document['_id'] = str(transaction_document['_id'])

        # Use dumps() to handle ObjectId serialization
        return json.dumps(transaction_document, default=str), 200, {'Content-Type': 'application/json'}
    else:
        response = jsonify({'message': 'Transaction not found'}), 404
        return response


@application.route('/add_cashier', methods=['POST'])
def add_cashier():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    name = data.get('name')
    type = data.get('type')
    document = {'name': name,
                'type': type,
                'incomes': 0,
                'expenses': 0,
                'user_id': user_id}
    is_present = cashiers_collection.find_one(document)
    if is_present is None:
        cashiers_collection.insert_one(document)
        return jsonify({'message': True}), 200
    else:
        return jsonify({'message': False}), 409


@application.route('/delete_cashier', methods=['POST'])
def delete_cashier():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401

    cashier_id = data.get('cashier_id')
    cashiers_collection.find_one_and_delete({'_id': ObjectId(cashier_id)})
    return jsonify({'message': True}), 200


@application.route('/cashiers', methods=['POST'])
def cashiers():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')
    keyword = data.get('keyword')
    page = data.get('page', 1)  # Default to page 1 if not provided
    per_page = data.get('per_page', 10)  # Default to 10 items per page if not provided
    archived = data.get('archived', False)  # Default to False if not provided

    filter_criteria = {'user_id': user_id}
    if keyword:
        cashiers_collection.create_index([("$**", "text")])
        filter_criteria['$text'] = {'$search': keyword}

    if not archived:
        filter_criteria['archived'] = {'$ne': True}

    # Count the total number of clients that match the filter criteria
    total_cashiers = cashiers_collection.count_documents(filter_criteria)
    total_pages = math.ceil(total_cashiers / per_page)

    # Paginate the query results using skip and limit, and apply filters
    skip = (page - 1) * per_page

    transactions = list(transactions_collection.find({'user_id': user_id}))
    cashiers = list(cashiers_collection.find({'user_id': user_id}))

    # Initialize dictionaries to store incomes, expenses, and balances for each cashier
    cashier_incomes = {}
    cashier_expenses = {}
    cashier_balances = {}

    for cashier in cashiers:
        cashier_name = cashier['name']
        cashier_incomes[cashier_name] = 0
        cashier_expenses[cashier_name] = 0
        cashier_balances[cashier_name] = 0

    for transaction in transactions:
        cashier_name = transaction['cashier']

        if transaction['type'] == 'На рахунок':
            cashier_incomes[cashier_name] += transaction['sum']
        elif transaction['type'] == 'З рахунку':
            cashier_expenses[cashier_name] += transaction['sum']

    # Update cashiers_collection for each cashier
    for cashier_name in cashier_incomes.keys():
        balance = cashier_incomes[cashier_name] - cashier_expenses[cashier_name]
        cashiers_collection.find_one_and_update({'name': cashier_name, 'user_id': user_id}, {
            '$set': {
                'incomes': cashier_incomes[cashier_name],
                'expenses': cashier_expenses[cashier_name],
                'balance': balance
            }
        })

    documents = list(cashiers_collection.find(filter_criteria).skip(skip).limit(per_page))
    for document in documents:
        document['_id'] = str(document['_id'])

    # Calculate the range of clients being displayed
    start_range = skip + 1
    end_range = min(skip + per_page, total_cashiers)

    cashiers = cashiers_collection.find({'user_id': user_id})
    total_incomes = 0
    total_expenses = 0
    for cashier in cashiers:
        total_incomes += cashier.get('incomes', 0)
        total_expenses += cashier.get('expenses', 0)
    total_balance = total_incomes - total_expenses

    # Serialize the documents using json_util from pymongo and specify encoding
    response = Response(json_util.dumps(
        {'cashiers': documents, 'total_cashiers': total_cashiers, 'start_range': start_range, 'end_range': end_range,
         'total_pages': total_pages, 'total_balance': total_balance, 'total_incomes': total_incomes,
         'total_expenses': total_expenses},
        ensure_ascii=False).encode('utf-8'),
                        content_type='application/json;charset=utf-8')
    return response, 200


@application.route('/add_counterpartie', methods=['POST'])
def add_counterpartie():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    name = data.get('name')
    is_present = counterparties_collection.find_one({'name': name,
                                                     'user_id': user_id})
    if is_present is None:
        counterparties_collection.insert_one({'name': name, 'user_id': user_id})
        return jsonify({'message': True}), 200
    else:
        return jsonify({'message': False}), 409


@application.route('/delete_counterpartie', methods=['POST'])
def delete_counterpartie():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401

    counterpartie_id = data.get('counterpartie_id')
    counterparties_collection.find_one_and_delete({'_id': ObjectId(counterpartie_id)})
    return jsonify({'message': True}), 200


@application.route('/counterparties', methods=['POST'])
def counterparties():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')
    keyword = data.get('keyword')

    filter_criteria = {'user_id': user_id}
    if keyword:
        regex_pattern = f'.*{re.escape(keyword)}.*'
        filter_criteria['name'] = {'$regex': regex_pattern, '$options': 'i'}

    # Retrieve all documents that match the filter criteria
    documents = list(counterparties_collection.find(filter_criteria))
    for document in documents:
        document['_id'] = str(document['_id'])

    # Serialize the documents using json_util from pymongo and specify encoding
    response = Response(json_util.dumps({'counterparties': documents}, ensure_ascii=False).encode('utf-8'),
                        content_type='application/json;charset=utf-8')
    return response, 200


@application.route('/change_product_warehouse', methods=['POST'])
def change_product_warehouse():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    product_id = data.get('product_id')
    warehouse = data.get('warehouse')
    subwarehouse = data.get('subwarehouse')

    products_collection.find_one_and_update({'_id': ObjectId(product_id)}, {'$set': {'warehouse': warehouse}})
    products_collection.find_one_and_update({'_id': ObjectId(product_id)}, {'$set': {'subwarehouse': subwarehouse}})

    return jsonify({'message': True})


@application.route("/send_mailing", methods=['POST'])
def send_mailing():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')
    type = data.get('type')
    subject = data.get('subject')
    recipients = data.get('recipients')
    text = data.get('text')

    today = datetime.today()
    if type == 'mail':
        recipients_names = []
        for recipient in recipients:
            msg = Message(subject=subject, sender='bagriul@gmail.com', recipients=[recipient])
            msg.body = text
            #mail.send(msg)
            client = clients_collection.find_one({'email': recipient})
            recipients_names.append({'client_name': client['name'], 'client_id': str(client['_id'])})
        document = {'date': today,
                    'subject': subject,
                    'text': text,
                    'amount': len(recipients),
                    'recipients': recipients_names,
                    'type': 'mail',
                    'user_id': user_id,}
        mailing_history_collection.insert_one(document)
        return jsonify({'message': True}), 200
    elif type == 'telegram':
        recipients_names = []
        for recipient in recipients:
            try:
                #bot.send_message(recipient, text)
                client = clients_collection.find_one({'tgID': recipient})
                recipients_names.append({'client_name': client['name'], 'client_id': str(client['_id'])})
            except Exception as e:
                print(e)
        document = {'date': today,
                    'text': text,
                    'amount': len(recipients),
                    'recipients': recipients_names,
                    'type': 'telegram',
                    'user_id': user_id}
        mailing_history_collection.insert_one(document)
        return jsonify({'message': True}), 200


@application.route('/new_mailing_list', methods=['POST'])
def new_mailing_list():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')
    min_price = data.get('min_price')
    max_price = data.get('max_price')
    min_total_price = data.get('min_total_price')
    max_total_price = data.get('max_total_price')
    category = data.get('category')

    filter_criteria = {'user_id': user_id}
    if category:
        filter_criteria['variations'] = {'$elemMatch': {'category': category}}

    if min_price is not None and max_price is not None:
        filter_criteria['variations'] = {
            '$elemMatch': {
                'price': {'$gte': min_price, '$lte': max_price}
            }
        }
    elif min_price is not None:
        filter_criteria['variations'] = {
            '$elemMatch': {
                'price': {'$gte': min_price}
            }
        }
    elif max_price is not None:
        filter_criteria['variations'] = {
            '$elemMatch': {
                'price': {'$lte': max_price}
            }
        }

    if min_total_price is not None and max_total_price is not None:
        filter_criteria['total_sum'] = {'$gte': min_price, '$lte': max_price}
    elif min_total_price is not None:
        filter_criteria['total_sum'] = {'$gte': min_price}
    elif max_total_price is not None:
        filter_criteria['total_sum'] = {'$lte': max_price}

    documents = list(orders_collection.find(filter_criteria))
    email_list = []
    for document in documents:
        client = clients_collection.find_one({'email': document['email']})
        email = client['email']
        if email not in email_list:
            email_list.append(email)

    return jsonify({'emails': email_list}), 200


@application.route('/get_category', methods=['POST'])
def get_category():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    filter_criteria = {'user_id': user_id}
    # Query to get all documents
    documents = orders_collection.find(filter_criteria)

    # Extract unique categories from the documents
    categories_set = set()
    for document in documents:
        variations = document.get('variations', [])
        for variation in variations:
            category = variation.get('category')
            if category:
                categories_set.add(category)

    # Convert the set of categories to a list
    categories_list = list(categories_set)
    response = Response(json_util.dumps(
        {'categories': categories_list},
        ensure_ascii=False).encode('utf-8'),
                        content_type='application/json;charset=utf-8')
    return response, 200


@application.route('/new_telegram_list', methods=['POST'])
def new_telegram_list():
    data = request.get_json()
    access_token = data.get('access_token')
    if check_token(access_token) is False:
        return jsonify({'token': False}), 401
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')
    min_price = data.get('min_price')
    max_price = data.get('max_price')
    min_total_price = data.get('min_total_price')
    max_total_price = data.get('max_total_price')
    category = data.get('category')

    filter_criteria = {'user_id': user_id}
    if category:
        filter_criteria['variations'] = {'$elemMatch': {'category': category}}

    if min_price is not None and max_price is not None:
        filter_criteria['variations'] = {
            '$elemMatch': {
                'price': {'$gte': min_price, '$lte': max_price}
            }
        }
    elif min_price is not None:
        filter_criteria['variations'] = {
            '$elemMatch': {
                'price': {'$gte': min_price}
            }
        }
    elif max_price is not None:
        filter_criteria['variations'] = {
            '$elemMatch': {
                'price': {'$lte': max_price}
            }
        }

    if min_total_price is not None and max_total_price is not None:
        filter_criteria['total_sum'] = {'$gte': min_price, '$lte': max_price}
    elif min_total_price is not None:
        filter_criteria['total_sum'] = {'$gte': min_price}
    elif max_total_price is not None:
        filter_criteria['total_sum'] = {'$lte': max_price}

    documents = list(orders_collection.find(filter_criteria))
    tgID_list = []
    for document in documents:
        client = clients_collection.find_one({'email': document['email']})
        try:
            tgID = client['tgID']
        except TypeError:
            continue
        except KeyError:
            continue
        if tgID not in tgID_list:
            tgID_list.append(tgID)

    return jsonify({'tgIDs': tgID_list}), 200


@application.route('/analytics', methods=['POST'])
def analytics():
    data = request.get_json() or {}
    access_token = data.get('access_token')

    if not check_token(access_token):
        return jsonify({'error': 'Invalid token'}), 401

    try:
        user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

        start_date = data.get('start_date', '')
        end_date = data.get('end_date', '')
        start_date = datetime.strptime(start_date, "%a %b %d %Y")
        end_date = datetime.strptime(end_date, "%a %b %d %Y") + timedelta(days=1)
    except (TypeError, ValueError) as e:
        response_data = {
            'sales_info': None,
            'returns_info': None,
            'top_products': None,
            'purchase_segmentation': None,
            'daily_analytics': None
        }
        return jsonify(response_data), 200

    sales_info = calculate_sales_info(user_id, start_date, end_date)
    returns_info = calculate_returns_info(user_id, start_date, end_date)
    top_products = calculate_top_products(user_id, start_date, end_date, data.get('product_category'))
    purchase_segmentation = calculate_purchase_segmentation(data, user_id)
    #mailing_history, total_documents = get_mailing_history(data, user_id)
    daily_analytics = calculate_daily_tasks_transactions_orders_sales(start_date, end_date, user_id)

    response_data = {
        **sales_info,
        **returns_info,
        'top_products': top_products,
        **purchase_segmentation,
        'daily_analytics': daily_analytics
    }

    return jsonify(response_data), 200


@application.route('/mailing_history', methods=['POST'])
def mailing_history():
    data = request.get_json() or {}
    access_token = data.get('access_token')

    if not check_token(access_token):
        return jsonify({'error': 'Invalid token'}), 401

    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    mailing_history, total_documents = get_mailing_history(data, user_id)

    response_data = {
        'mailing_history': mailing_history,
        'total_documents': total_documents
    }

    return jsonify(response_data), 200


def calculate_daily_tasks_transactions_orders_sales(start_date, end_date, user_id):
    # Initialize a dictionary to hold day-by-day data
    daily_data = {}
    current_date = start_date
    while current_date < end_date:
        date_key = current_date.strftime('%Y-%m-%d')
        daily_data[date_key] = {'orders': 0, 'sales': 0, 'active_tasks': 0, 'transactions': 0, 'products': 0}
        current_date += timedelta(days=1)

    # Query for orders and sales
    orders_and_sales = orders_collection.aggregate([
        {
            '$match': {
                'user_id': user_id,
                'date': {'$gte': start_date, '$lt': end_date}
            }
        },
        {
            '$group': {
                '_id': {
                    'date': {'$dateToString': {'format': '%Y-%m-%d', 'date': '$date'}},
                    'status': '$status.status'
                },
                'count': {'$sum': 1}
            }
        }
    ])
    for item in orders_and_sales:
        date_key = item['_id']['date']
        if item['_id']['status'] == 'Оплачено':
            daily_data[date_key]['sales'] += item['count']
        daily_data[date_key]['orders'] += item['count']

    # Query specifically for transactions
    transactions = transactions_collection.aggregate([
        {
            '$match': {
                'user_id': user_id,
                'date': {'$gte': start_date, '$lt': end_date}
            }
        },
        {
            '$group': {
                '_id': {'$dateToString': {'format': '%Y-%m-%d', 'date': '$date'}},
                'count': {'$sum': 1}
            }
        }
    ])
    for item in transactions:
        date_key = item['_id']
        daily_data[date_key]['transactions'] += item['count']

    # Query specifically for products
    products = products_collection.aggregate([
        {
            '$match': {
                'user_id': user_id,
                'date': {'$gte': start_date, '$lt': end_date}
            }
        },
        {
            '$group': {
                '_id': {'$dateToString': {'format': '%Y-%m-%d', 'date': '$date'}},
                'count': {'$sum': 1}
            }
        }
    ])
    for item in products:
        date_key = item['_id']
        daily_data[date_key]['products'] += item['count']

    # Query specifically for active tasks
    active_tasks = tasks_collection.aggregate([
        {
            '$match': {
                'user_id': user_id,
                'date': {'$gte': start_date, '$lt': end_date},
                'status': {'$ne': 'Завершено'}
            }
        },
        {
            '$group': {
                '_id': {'$dateToString': {'format': '%Y-%m-%d', 'date': '$date'}},
                'count': {'$sum': 1}
            }
        }
    ])
    for item in active_tasks:
        date_key = item['_id']
        daily_data[date_key]['active_tasks'] += item['count']

    return daily_data


def calculate_sales_or_returns_info(user_id, start_date, end_date):
    filter_criteria = {
        'user_id': user_id,
        'date': {"$gte": start_date, "$lt": end_date},
        'status.status': {'$in': ['Оплачено', 'Повернено', 'Скасовано']}
    }
    documents = list(orders_collection.find(filter_criteria))

    sales_total_sum = returns_total_sum = canceled_total_sum = 0
    sales_count = returns_count = canceled_count = 0
    sales_daily_info = {}
    returns_daily_info = {}
    canceled_daily_info = {}

    for doc in documents:
        date_key = doc['date'].strftime('%Y-%m-%d')
        status = doc['status']['status']
        if status == 'Оплачено':
            sales_total_sum += doc['total_sum']
            sales_count += 1
            if date_key not in sales_daily_info:
                sales_daily_info[date_key] = {'total_sum': 0, 'count': 0}
            sales_daily_info[date_key]['total_sum'] += doc['total_sum']
            sales_daily_info[date_key]['count'] += 1
        elif status == 'Повернено':
            returns_total_sum += doc['total_sum']
            returns_count += 1
            if date_key not in returns_daily_info:
                returns_daily_info[date_key] = {'total_sum': 0, 'count': 0}
            returns_daily_info[date_key]['total_sum'] += doc['total_sum']
            returns_daily_info[date_key]['count'] += 1
        elif status == 'Скасовано':
            canceled_total_sum += doc['total_sum']
            canceled_count += 1
            if date_key not in canceled_daily_info:
                canceled_daily_info[date_key] = {'total_sum': 0, 'count': 0}
            canceled_daily_info[date_key]['total_sum'] += doc['total_sum']
            canceled_daily_info[date_key]['count'] += 1

    sales_average_check = sales_total_sum / sales_count if sales_count else 0
    returns_average_check = returns_total_sum / returns_count if returns_count else 0
    canceled_average_check = canceled_total_sum / canceled_count if canceled_count else 0

    return {
        'sales_total_sum': sales_total_sum,
        'sales_average_check': sales_average_check,
        'sales_amount': sales_count,
        'daily_sales_info': sales_daily_info,
        'returns_total_sum': returns_total_sum,
        'returns_average_check': returns_average_check,
        'returns_amount': returns_count,
        'daily_returns_info': returns_daily_info,
        'canceled_total_sum': canceled_total_sum,
        'canceled_average_check': canceled_average_check,
        'canceled_amount': canceled_count,
        'daily_canceled_info': canceled_daily_info
    }


def calculate_sales_info(user_id, start_date, end_date):
    return calculate_sales_or_returns_info(user_id, start_date, end_date)


def calculate_returns_info(user_id, start_date, end_date):
    return calculate_sales_or_returns_info(user_id, start_date, end_date)


def calculate_top_products(user_id, start_date, end_date, category=None):
    # Match stage to filter orders by user_id, date, and optionally by category within variations
    match_stage = {
        '$match': {
            'user_id': user_id,
            'date': {'$gte': start_date, '$lt': end_date},
            'status.status': 'Оплачено',  # Assuming you want to filter by paid orders
        }
    }

    # Unwind the variations array to treat each product as a separate document
    unwind_stage = {
        '$unwind': '$variations'
    }

    # Optional category match stage if a category is provided
    if category:
        category_match_stage = {
            '$match': {
                'variations.category': category
            }
        }
    else:
        category_match_stage = {}

    # Group stage to aggregate products, count their occurrences, and sum the amounts
    group_stage = {
        '$group': {
            '_id': {
                'product_name': '$variations.name',
                'product_category': '$variations.category',
            },
            'count': {'$sum': 1},
            'total_amount': {'$sum': '$variations.amount'}  # Sum the total amount sold for each product
        }
    }

    # Sort stage to order the results by count and total_amount (if you want to prioritize higher sales volume)
    sort_stage = {
        '$sort': {'count': -1, 'total_amount': -1}
    }

    # Limit stage to get the top 5 products
    limit_stage = {
        '$limit': 5
    }

    # Building the pipeline conditionally based on whether a category filter is applied
    pipeline = [match_stage, unwind_stage]
    if category:
        pipeline.append(category_match_stage)
    pipeline.extend([group_stage, sort_stage, limit_stage])

    # Execute the aggregation pipeline
    top_products = list(orders_collection.aggregate(pipeline))

    # Format results for readability
    formatted_results = [{
        'product_name': product['_id']['product_name'],
        'product_category': product['_id']['product_category'],
        'sold_count': product['count'],
        'total_amount': product['total_amount']
    } for product in top_products]

    return formatted_results


def calculate_purchase_segmentation(data, user_id):
    filter_criteria = {'user_id': user_id}
    for field in ['gender', 'variations.category']:
        key = f'purchase_segmentation_{field.split(".")[-1]}' # Adjust key to match input data
        value = data.get(key)
        if value:
            if 'gender' in field:
                filter_criteria['gender'] = {'$regex': f'.*{re.escape(value)}.*', '$options': 'i'}
            else:  # Handle category within variations
                filter_criteria['variations'] = {'$elemMatch': {'category': value}}

    documents = list(orders_collection.find(filter_criteria))
    purchase_segmentation_sum = sum(doc['total_sum'] for doc in documents)

    return {
        'purchase_segmentation_amount': len(documents),
        'purchase_segmentation_sum': purchase_segmentation_sum
    }


def get_mailing_history(data, user_id):
    mailing_type = data.get('mailing_type')
    page = data.get('page', 1)
    per_page = data.get('per_page', 10)

    filter_criteria = {'user_id': user_id}
    if mailing_type:
        filter_criteria['type'] = {'$regex': f'.*{re.escape(mailing_type)}.*', '$options': 'i'}

    total_documents = mailing_history_collection.count_documents(filter_criteria)
    documents = list(
        mailing_history_collection.find(filter_criteria)
        .skip((page - 1) * per_page)
        .limit(per_page)
    )

    # Convert ObjectIds to strings for JSON serialization
    for doc in documents:
        doc['_id'] = str(doc['_id'])

    return documents, total_documents


@application.route('/all_variations', methods=['POST'])
def all_variations():
    # Get data from request
    data = request.get_json()

    # Extract access token from data
    access_token = data.get('access_token')

    # Check if the access token is valid
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    # Decode user_id from access token
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    # Retrieve all products from the database
    products = products_collection.find({'user_id': user_id})

    # Initialize an empty list to store all variations
    all_variations = []

    # Iterate through each product
    for product in products:
        # Get product name and id
        product_name = product['name']
        product_id = str(product['_id'])

        # Iterate through each variation of the product
        for variation in product['variations']:
            # Add product name and id to the variation
            variation['product_name'] = product_name
            variation['product_id'] = product_id

            # Add the variation to the list of all variations
            all_variations.append(variation)

    # Return the list of all variations as JSON response
    return jsonify({'variations': all_variations}), 200


@application.route('/update_variation', methods=['POST'])
def update_variation():
    # Get data from request
    data = request.get_json()

    # Extract access token from data
    access_token = data.get('access_token')

    # Check if the access token is valid
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    # Decode user_id from access token
    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    # Extract product ID, variation ID, and the parameters to update
    product_id = data.get('product_id')
    variation_id = data.get('variation_id')
    updates = data.get('updates')  # This should be a dictionary of the parameters to update

    # Validate required fields
    if not product_id or not variation_id or not updates:
        return jsonify({'message': False}), 400

    # Retrieve the specific product
    product = products_collection.find_one({'_id': ObjectId(product_id), 'user_id': user_id})

    if not product:
        return jsonify({'message': False}), 404

    # Find the variation to update
    variation_found = False
    for variation in product['variations']:
        if str(variation['_id']) == variation_id:
            # Update the necessary fields in the variation
            for key, value in updates.items():
                if key in ['cost_price', 'price', 'in_stock', 'recommended_balance_amount']:
                    variation[key] = value
            variation_found = True
            break

    if not variation_found:
        return jsonify({'message': False}), 404

    # Update the product in the database
    products_collection.update_one(
        {'_id': ObjectId(product_id), 'user_id': user_id},
        {'$set': {'variations': product['variations']}}
    )

    return jsonify({'message': True}), 200


@application.route('/settings', methods=['POST'])
def handle_settings():
    data = request.get_json()
    setting_type = data.get('setting_type')
    if setting_type == 'add':
        return add_setting(request)
    elif setting_type == 'view':
        return view_settings(request)
    elif setting_type == 'delete':
        return delete_setting(request)
    else:
        return jsonify({'message': False}), 405


def add_setting(request):
    data = request.get_json()
    access_token = data.get('access_token')

    # Check token validity
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    # Extract setting type from the request data
    data_type = data.get('data_type')

    # Extract setting data
    setting_data = data.get('data')
    setting_data['user_id'] = user_id

    # Handle different setting types
    collections_map = {
        'status': statuses_collection,
        'counterparty': counterparties_collection,
        'task_participant': task_participants_collection,
        'product_category': products_categories_collection,
        'subwarehouse': warehouses_collection,
        'shipping_method': shipping_methods_collection,
        'order_source': order_sources_collection,
        'payment_method': payment_methods_collection
    }

    # Insert setting data into the appropriate collection
    if data_type in collections_map:
        collection = collections_map[data_type]

        # Check if counterparty already exists
        if data_type == 'counterparty':
            counterparty_name = setting_data.get('name')
            existing_counterparty = collection.find_one({'name': counterparty_name, 'user_id': user_id})
            if existing_counterparty:
                return jsonify({'message': 'Counterparty already exists'}), 400

        collection.insert_one(setting_data)
        return jsonify({'message': True}), 200
    else:
        return jsonify({'message': False}), 400


def view_settings(request):
    data = request.get_json()
    access_token = data.get('access_token')

    # Check token validity
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    # Extract setting type from the request data
    data_type = data.get('data_type')

    # Handle different setting types
    collections_map = {
        'status': statuses_collection,
        'counterparty': counterparties_collection,
        'task_participant': task_participants_collection,
        'product_category': products_categories_collection,
        'subwarehouse': warehouses_collection,
        'shipping_method': shipping_methods_collection,
        'order_source': order_sources_collection,
        'payment_method': payment_methods_collection
    }

    # Retrieve settings data from the appropriate collection
    if data_type in collections_map:
        collection = collections_map[data_type]
        settings = list(collection.find({"$or": [{"user_id": user_id}, {"user_id": "0"}]}))
        for setting in settings:
            setting['_id'] = str(setting['_id'])
        return jsonify({'settings': settings}), 200
    else:
        return jsonify({'message': False}), 400


def delete_setting(request):
    data = request.get_json()
    access_token = data.get('access_token')

    # Check token validity
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    # Extract setting type and setting ID from the request data
    data_type = data.get('data_type')
    setting_id = data.get('setting_id')

    # Handle different setting types
    collections_map = {
        'status': statuses_collection,
        'counterparty': counterparties_collection,
        'task_participant': task_participants_collection,
        'product_category': products_categories_collection,
        'subwarehouse': warehouses_collection,
        'shipping_method': shipping_methods_collection,
        'order_source': order_sources_collection,
        'payment_method': payment_methods_collection
    }

    # Retrieve the appropriate collection based on the setting type
    if data_type in collections_map:
        collection = collections_map[data_type]

        # Delete the setting from the collection
        result = collection.delete_one({'_id': ObjectId(setting_id), 'user_id': user_id})

        # Check if the setting was successfully deleted
        if result.deleted_count == 1:
            return jsonify({'message': True}), 200
        else:
            return jsonify({'message': False}), 404
    else:
        return jsonify({'message': False}), 400


@application.route('/quick_action', methods=['POST'])
def quick_action():
    data = request.get_json()
    access_token = data.get('access_token')

    # Check token validity
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    document_type = data.get('document_type')
    action = data.get('action')
    document_ids = data.get('document_ids', [])

    # Convert document IDs to ObjectId
    document_ids = [ObjectId(doc_id) for doc_id in document_ids]

    # Map document types to their respective collections
    collections = {
        'clients': clients_collection,
        'tasks': tasks_collection,
        'finance': transactions_collection,
        'warehouses': products_collection,
        'orders': orders_collection
    }

    # Ensure valid document type
    if document_type not in collections:
        return jsonify({'message': False}), 400

    collection = collections[document_type]

    # Handle actions
    if action in ['delete']:
        delete_documents(collection, document_ids)
    elif action in ['change_status', 'change_comment', 'change_responsible', 'change_deadline', 'change_participants',
                    'change_cashier', 'change_counterpartie', 'change_sum', 'change_name', 'change_warehouse',
                    'change_subwarehouse', 'change_category', 'change_client', 'change_source', 'change_shipping',
                    'change_payment']:
        if action == 'change_status':
            status = data.get('status')
            type = data.get('type')
            status_doc = find_status_document(status, type)

            # Check for orders with status "Оплачено"
            if document_type == 'orders':
                paid_orders = list(collection.find({'_id': {'$in': document_ids}, 'status.status': 'Оплачено'}))
                if paid_orders:
                    paid_order_ids = [str(order['_id']) for order in paid_orders]
                    return jsonify({'error': 'Cannot change status of paid orders', 'ids': paid_order_ids}), 400

            update_documents(collection, document_ids, {'status': status_doc})
        elif action in ['change_comment', 'change_responsible', 'change_deadline', 'change_participants',
                        'change_cashier', 'change_counterpartie', 'change_name', 'change_warehouse',
                        'change_subwarehouse', 'change_category', 'change_source', 'change_shipping',
                        'change_payment']:
            update_field = action.split('_')[1]
            update_value = data.get(update_field)
            if action == 'change_deadline':
                update_value = datetime.strptime(update_value, "%a %b %d %Y")
            update_documents(collection, document_ids, {update_field: update_value})
        elif action == 'change_client':
            client = data.get('client')
            update_documents(collection, document_ids,
                             {'client': client, 'email': client['email'], 'gender': client['gender']})
        elif action == 'change_sum':
            # Custom handling for changing sum with additional logic
            handle_change_sum(collection, document_ids, data.get('sum'))
    else:
        return jsonify({'message': False}), 400

    return jsonify({'message': True}), 200


def update_documents(collection, document_ids, update):
    """Update documents in a specified collection."""
    collection.update_many({'_id': {'$in': document_ids}}, {'$set': update})


def delete_documents(collection, document_ids):
    """Delete documents from a specified collection."""
    collection.delete_many({'_id': {'$in': document_ids}})


def find_status_document(status, type):
    """Find a status document and remove its ID."""
    status_doc = statuses_collection.find_one({'status': status, 'type': type})
    if status_doc:
        del status_doc['_id']
    return status_doc


def handle_change_sum(collection, document_ids, new_sum):
    """
    Update the sum for transactions and adjust the total_left accordingly.

    Args:
        collection: The MongoDB collection to operate on.
        document_ids: List of document IDs to update.
        new_sum: The new sum to apply to the transactions.
    """
    # Retrieve the current transactions to calculate the difference
    transactions_old = list(collection.find({'_id': {'$in': document_ids}}, {'sum': 1, 'total_left': 1}))

    # Update the transactions with the new sum
    update_result = collection.update_many({'_id': {'$in': document_ids}}, {'$set': {'sum': new_sum}})

    # Check if the transactions were successfully updated to proceed with adjustments
    if update_result.modified_count > 0:
        for transaction_old in transactions_old:
            # Calculate the difference between the old and new sums
            diff = transaction_old['sum'] - new_sum
            # Adjust the total_left by adding the difference
            # Assuming total_left is a field in the same document
            collection.update_one({'_id': transaction_old['_id']}, {'$inc': {'total_left': diff}})


@application.route('/add_loyalty', methods=['POST'])
def add_loyalty():
    data = request.get_json()
    access_token = data.get('access_token')

    # Check token validity
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    date = datetime.strptime(data.get('date'), "%a %b %d %Y")
    discount = data.get('discount')
    category = data.get('category')

    document = {'date': date,
                'discount': discount,
                'category': category,
                'user_id': user_id}

    loyalty_collection.insert_one(document)

    notification = {'text': f'Знижка {discount}% на {category} почне діяти {date}',
                    'user_id': user_id}
    notifications_collection.insert_one(notification)

    return jsonify({'message': True}), 200


@application.route('/loyalty', methods=['POST'])
def loyalty():
    data = request.get_json()
    access_token = data.get('access_token')

    # Check token validity
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    loyalty = list(loyalty_collection.find({'user_id': user_id}))
    for document in loyalty:
        document['_id'] = str(document['_id'])

    return jsonify({'loyalty': loyalty}), 200


@application.route('/delete_loyalty', methods=['POST'])
def delete_loyalty():
    data = request.get_json()
    access_token = data.get('access_token')

    # Check token validity
    if not check_token(access_token):
        return jsonify({'token': False}), 401

    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')

    loyalty_id = data.get('loyalty_id')

    loyalty = loyalty_collection.find_one({'_id': ObjectId(loyalty_id)})

    loyalty_collection.delete_one({'_id': ObjectId(loyalty_id)})

    notification = {'text': f'Знижку {loyalty["discount"]}% на {loyalty["category"]} {loyalty["date"]} видалено',
                    'user_id': user_id}
    notifications_collection.insert_one(notification)

    return jsonify({'message': True}), 200


@application.route('/archive_cashier', methods=['POST'])
def archive_cashier():
    data = request.get_json()
    access_token = data.get('access_token')

    if not check_token(access_token):
        return jsonify ({'token': False}), 401

    cashier_id = data.get('cashier_id')
    archive = data.get('archive', True)

    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')
    cashier = cashiers_collection.find_one({'_id': ObjectId(cashier_id)})
    cashiers_collection.find_one_and_update(cashier,
                                            {'$set': {'archived': archive}})
    transactions = transactions_collection.find({'user_id': user_id, 'cashier': cashier['name']})
    for transaction in transactions:
        transactions_collection.find_one_and_update(transaction, {'$set': {'archived': archive}})

    return jsonify({'message': True}), 200


@application.route('/profile', methods=['POST'])
def profile():
    data = request.get_json()
    access_token = data.get('access_token')

    if not check_token(access_token):
        return jsonify({'token': False}), 401

    user_id = decode_access_token(access_token, SECRET_KEY).get('user_id')
    user = users_collection.find_one({'_id': ObjectId(user_id)})
    user['_id'] = str(user['_id'])
    try:
        user['subscription_end'] = datetime.strftime(user['subscription_end'], "%a %b %d %Y")
    except KeyError:
        pass

    return jsonify({'user': user}), 200



if __name__ == '__main__':
    application.run(port=8000)
